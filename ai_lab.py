# -*- coding: utf-8 -*-
"""AI-lab.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Q2hJj4ChZrXsmH-4wiGFlasnL4u8q0Vh

**# Ali raza(SP23-BSE-159)**
"""

from collections import deque
import heapq

def is_valid(state):
    """Check if a given state is valid."""
    M_left, C_left, boat = state
    M_right = 3 - M_left
    C_right = 3 - C_left

    if M_left < 0 or M_right < 0 or C_left < 0 or C_right < 0:
        return False

    if (M_left > 0 and C_left > M_left) or (M_right > 0 and C_right > M_right):
        return False

    return True


def successors(state):
    """Generate all possible successor states."""
    M_left, C_left, boat = state
    moves = [(1,0), (2,0), (0,1), (0,2), (1,1)]

    succ = []
    for m, c in moves:
        if boat == 'left':
            new_state = (M_left - m, C_left - c, 'right')
        else:
            new_state = (M_left + m, C_left + c, 'left')
        if is_valid(new_state):
            succ.append(new_state)
    return succ


def print_path(path):
    """Display all intermediate states from start to goal."""
    print("\nPath from Start to Goal:")
    for i, state in enumerate(path):
        print(f"Step {i}: {state}")
    print("\nTotal Steps:", len(path)-1)


def bfs(start, goal):
    queue = deque([[start]])
    visited = set()

    while queue:
        path = queue.popleft()
        state = path[-1]
        if state == goal:
            return path
        if state in visited:
            continue
        visited.add(state)

        for next_state in successors(state):
            new_path = list(path)
            new_path.append(next_state)
            queue.append(new_path)
    return None


def dfs(start, goal):
    stack = [[start]]
    visited = set()

    while stack:
        path = stack.pop()
        state = path[-1]
        if state == goal:
            return path
        if state in visited:
            continue
        visited.add(state)

        for next_state in successors(state):
            new_path = list(path)
            new_path.append(next_state)
            stack.append(new_path)
    return None


def heuristic(state):
    """Heuristic: number of people left / 2"""
    M_left, C_left, _ = state
    return (M_left + C_left) // 2


def a_star(start, goal):
    frontier = []
    heapq.heappush(frontier, (0 + heuristic(start), [start]))
    visited = set()

    while frontier:
        cost, path = heapq.heappop(frontier)
        state = path[-1]
        if state == goal:
            return path
        if state in visited:
            continue
        visited.add(state)

        for next_state in successors(state):
            new_path = list(path)
            new_path.append(next_state)
            g = len(new_path)
            f = g + heuristic(next_state)
            heapq.heappush(frontier, (f, new_path))
    return None

if __name__ == "__main__":
    start = (3, 3, 'left')
    goal = (0, 0, 'right')

    print("\n==================== BFS ====================")
    path_bfs = bfs(start, goal)
    print_path(path_bfs)

    print("\n==================== DFS ====================")
    path_dfs = dfs(start, goal)
    print_path(path_dfs)

    print("\n==================== A* Search ====================")
    path_astar = a_star(start, goal)
    print_path(path_astar)